;********************************************************************************************
;2021/3/19 作成 ロウ@TW夢子口上の人
;
;Licence  :ライセンスフリー(CC0)。
;
;グラフィック表示簡易化ライブラリ G,CBG関連関数対応版
;なんかややこしいグラフィック表示関連を簡単に表示できるようにまとめたもの。
;GIDの管理とかいちいちめんどくさいし、解放忘れそうだし重複しそうだからっていうことで作りました。
;********************************************************************************************

;********************************************************************************************
;グラフィックID登録関数
;これを呼ぶとグラフィックを一つ作成でき、戻り値でそのIDを取得できる。
;作るだけなので中身は空っぽ。
;自動走査でグラフィックIDを作成したい場合に使用する。
;********************************************************************************************
@グラフィックID登録(WIDTH, HEIGHT)
#FUNCTION
#DIM グラフィックID
#DIM WIDTH
#DIM HEIGHT
;前回呼び出されていれば続きから始める
グラフィックID = NEXT_GID
WHILE GCREATED(グラフィックID)
	;空いているグラフィックIDを走査する
	グラフィックID ++
WEND
;次回は続きから走査するように設定
NEXT_GID = グラフィックID + 1
;グラフィックの取り込み
IF !GCREATE(グラフィックID, WIDTH, HEIGHT)
	DEBUGPRINTFORML グラフィックの作成に失敗しました。
	RETURNF 0
ENDIF
;DEBUGPRINTFORML グラフィック番号「{グラフィックID}」を登録しました。
RETURNF グラフィックID

;********************************************************************************************
;グラフィック背景表示関数
;これを呼ぶとリソースファイルをそのまま一枚表示できる
;このまま使用するとサイズが指定できないため、あまり便利ではないのでCBG画像表示Sの使用を推奨する。
;ぶっちゃけこの関数はリソースファイルを直接描画できるようにCBGSETGを呼んでいるだけです。
;********************************************************************************************
@CBG画像表示G(リソースファイル名, x座標, y座標, z座標 = -1)
#DIMS リソースファイル名	;参照するリソースファイル名称
#DIM x座標					;描画する際のx座標 左下基準
#DIM y座標					;描画する際のy座標 左下基準
#DIM z座標					;描画する際のz座標 0がテキスト描画領域 負数は手前を表す
#DIM グラフィックID			;使用するグラフィックID
;y座標を反転させる
y座標 = -y座標
;既に読み込まれているリソースファイル名である場合、そのグラフィックIDを使用する
FOR LOCAL, 0, GPL保有GID数
	SIF GPLリソース名:LOCAL == ""
		BREAK
	IF GPLリソース名:LOCAL == リソースファイル名
		グラフィックID = GPLグラフィックID:LOCAL
		LOCAL-- ;BREAK時に何故か再び加算されてしまうのでデクリメント
		BREAK
	ENDIF
NEXT
;グラフィックIDがまだ作成されていないなら新規登録する
IF LOCAL == GPL保有GID数
	;前回呼び出されていれば続きから始める
	グラフィックID = NEXT_GID
	WHILE GCREATED(グラフィックID)
		;空いているグラフィックIDを走査する
		グラフィックID ++
	WEND
	;次回は続きから走査するように設定
	NEXT_GID = グラフィックID + 1
	;グラフィックの取り込み
	IF !GCREATE_拡張子F(グラフィックID, リソースファイル名)
		DEBUGPRINTFORML グラフィックの作成に失敗しました。
		DEBUGPRINTFORML リソースが見つからなかった可能性があります。
		RETURN 0
	ENDIF
	GPLグラフィックID:GPL保有GID数 = グラフィックID
	GPLリソース名:GPL保有GID数 '= リソースファイル名
	GPL保有GID数++
	;DEBUGPRINTFORML グラフィック番号「{グラフィックID}」に「%リソースファイル名%」を登録しました。
ENDIF
;グラフィックをクライアント領域に描画する
CBGSETG グラフィックID, x座標, y座標, z座標
RETURN 1

;********************************************************************************************
;スプライト背景表示関数
;これを呼ぶとサイズを指定した上でスプライトをクライアント領域に表示できる
;サイズを指定した場合は、新たなグラフィックIDの作成が必要になるため、廃棄対象となる
;z座標を使用して縦幅横幅を使用しない場合は0を入れます
;CBGSETSPRITE関数を便利に使いたいがための関数です
;********************************************************************************************
@CBG画像表示S(スプライト名, x座標, y座標, 横幅 = 0, 縦幅 = 0, z座標 = -1)
#DIMS スプライト名	;参照するリソースファイル名称
#DIM x座標					;描画する際のx座標 左下基準
#DIM y座標					;描画する際のy座標 左下基準
#DIM z座標					;描画する際のz座標 0がテキスト描画領域 負数は手前を表す
#DIM 横幅					;描画する際の横幅
#DIM 縦幅					;描画する際の縦幅
#DIM グラフィックID			;使用するグラフィックID
;指定したスプライト名が存在しない場合は関数を終了する
SIF !SPRITECREATED(@"%スプライト名%")
	RETURN 0
;y座標を反転させる
y座標 = -y座標
;縦幅横幅が指定されていた場合は新たにスプライトを作成する
IF !(縦幅 == 0 || 縦幅 == SPRITEHEIGHT(スプライト名)) && !(横幅 == 0 || 横幅 == SPRITEWIDTH(スプライト名))
	;同じ大きさのスプライトが登録されていない場合、グラフィックIDを新規登録する
	IF !SPRITECREATED(@"%スプライト名%_{横幅}_{縦幅}")
		;グラフィックIDを新規登録する
		;前回呼び出されていれば続きから始める
		グラフィックID = NEXT_GID
		WHILE GCREATED(グラフィックID)
			;空いているグラフィックIDを走査する
			グラフィックID ++
		WEND
		;次回は続きから走査するように設定
		NEXT_GID = グラフィックID + 1
		;グラフィックの取り込み
		GCREATE グラフィックID, 横幅, 縦幅
		IF RESULT == 0
			DEBUGPRINTFORML グラフィックの作成に失敗しました。
			RETURN 0
		ENDIF
		GDRAWSPRITE グラフィックID, スプライト名, 0, 0, 横幅, 縦幅
		GPLグラフィックID:GPL保有GID数 = グラフィックID
		GPLリソース名:GPL保有GID数 '= "[[BUF]]" + スプライト名 + "_" + TOSTR(縦幅) + "_" + TOSTR(横幅)
		GPL保有GID数++
		;DEBUGPRINTFORML グラフィック番号「{グラフィックID}」に「%スプライト名%_{横幅}_{縦幅}」を登録しました。
		SPRITECREATE @"%スプライト名%_{横幅}_{縦幅}", グラフィックID
	ENDIF
	;グラフィックをクライアント領域に描画する
	CBGSETSPRITE @"%スプライト名%_{横幅}_{縦幅}", x座標, y座標, z座標
ELSE
	;縦幅横幅の設定が無いならそのまま描画する
	CBGSETSPRITE スプライト名, x座標, y座標, z座標
ENDIF
RETURN 1

;********************************************************************************************
;スプライト背景ボタン表示関数
;これを呼ぶとサイズを指定した上でスプライトを使用したボタンをクライアント領域に表示できる
;サイズを指定した場合は、新たなグラフィックIDの作成が必要になるため、廃棄対象となる
;z座標を使用して縦幅横幅を使用しない場合は0を入れます
;CBGSETBUTTONSPRITE関数を便利に使いたいがための関数です
;********************************************************************************************
@CBGボタン表示S(ボタン番号, スプライト名, スプライト名B, x座標, y座標, 横幅 = 0, 縦幅 = 0, z座標 = -1)
#DIM ボタン番号				;押下した際のボタン番号
#DIMS スプライト名			;参照するリソースファイル名称
#DIMS スプライト名B			;参照するリソースファイル名称
#DIMS 表示スプライト名		;参照するリソースファイル名称
#DIMS 表示スプライト名B		;参照するリソースファイル名称
#DIM x座標					;描画する際のx座標 左下基準
#DIM y座標					;描画する際のy座標 左下基準
#DIM z座標					;描画する際のz座標 0がテキスト描画領域 負数は手前を表す
#DIM 縦幅					;描画する際の縦幅
#DIM 横幅					;描画する際の横幅
#DIM グラフィックID			;使用するグラフィックID
;指定したスプライト名が存在しない場合は関数を終了する
SIF !SPRITECREATED(@"%スプライト名%") ||  !SPRITECREATED(@"%スプライト名B%")
	RETURN 0
;y座標を反転させる
y座標 = -y座標
;ボタンマップ用グラフィックが既にある場合、そのグラフィックIDを使用する
FOR LOCAL, 0, GPL保有GID数
	SIF GPLリソース名:LOCAL == ""
		BREAK
	IF GPLリソース名:LOCAL == "[[ボタンマップ]]"
		グラフィックID = GPLグラフィックID:LOCAL
		LOCAL-- ;BREAK時に何故か再び加算されてしまうのでデクリメント
		BREAK
	ENDIF
NEXT
;ボタンマップのグラフィックIDがまだ作成されていないなら新規登録する
IF LOCAL == GPL保有GID数
	;前回呼び出されていれば続きから始める
	グラフィックID = NEXT_GID
	WHILE GCREATED(グラフィックID)
		;空いているグラフィックIDを走査する
		グラフィックID ++
	WEND
	;次回は続きから走査するように設定
	NEXT_GID = グラフィックID + 1
	;グラフィックの作成
	GCREATE グラフィックID, CLIENTWIDTH(), CLIENTHEIGHT()
	GPLグラフィックID:GPL保有GID数 = グラフィックID
	GPLリソース名:GPL保有GID数 '= "[[ボタンマップ]]"
	GPL保有GID数++
	DEBUGPRINTFORML グラフィック番号「{グラフィックID}」に「[[ボタンマップ]]」を登録しました。
ENDIF

;ボタンマップに指定されたサイズとカラーの四角系を描画し、マップをセットする
GSETBRUSH グラフィックID, 0xFF000000 + ボタン番号
GFILLRECTANGLE グラフィックID, x座標, CLIENTHEIGHT() + y座標 - 縦幅, 横幅, 縦幅
CBGSETBMAPG グラフィックID

;縦幅横幅が指定されていた場合は新たにスプライトを作成する
IF !(縦幅 == 0 || 縦幅 == SPRITEHEIGHT(スプライト名)) && !(横幅 == 0 || 横幅 == SPRITEWIDTH(スプライト名))
	;同じ大きさのスプライトが登録されていない場合、グラフィックIDを新規登録する
	IF !SPRITECREATED(@"%スプライト名%_{横幅}_{縦幅}")
		;グラフィックIDを新規登録する
		;前回呼び出されていれば続きから始める
		グラフィックID = NEXT_GID
		WHILE GCREATED(グラフィックID)
			;空いているグラフィックIDを走査する
			グラフィックID ++
		WEND
		;次回は続きから走査するように設定
		NEXT_GID = グラフィックID + 1
		;グラフィックの取り込み
		GCREATE グラフィックID, 横幅, 縦幅
		IF RESULT == 0
			DEBUGPRINTFORML グラフィックの作成に失敗しました。
			RETURN 0
		ENDIF
		GDRAWSPRITE グラフィックID, スプライト名, 0, 0, 横幅, 縦幅
		GPLグラフィックID:GPL保有GID数 = グラフィックID
		GPLリソース名:GPL保有GID数 '= "[[BUF]]" + スプライト名 + "_" + TOSTR(縦幅) + "_" + TOSTR(横幅)
		GPL保有GID数++
	;	DEBUGPRINTFORML グラフィック番号「{グラフィックID}」に「%スプライト名%_{横幅}_{縦幅}」を登録しました。
		SPRITECREATE @"%スプライト名%_{横幅}_{縦幅}", グラフィックID
	ENDIF
	表示スプライト名 '= スプライト名 + "_" + TOSTR(縦幅) + "_" + TOSTR(横幅)
ELSE
	;縦幅横幅の設定が無いならそのまま描画する
	表示スプライト名 '= スプライト名
ENDIF

IF !(縦幅 == 0 || 縦幅 == SPRITEHEIGHT(スプライト名B)) && !(横幅 == 0 || 横幅 == SPRITEWIDTH(スプライト名B))
	;同じ大きさのスプライトが登録されていない場合、グラフィックIDを新規登録する
	IF !SPRITECREATED(@"%スプライト名B%_{横幅}_{縦幅}")
		;グラフィックIDを新規登録する
		;前回呼び出されていれば続きから始める
		グラフィックID = NEXT_GID
		WHILE GCREATED(グラフィックID)
			;空いているグラフィックIDを走査する
			グラフィックID ++
		WEND
		;次回は続きから走査するように設定
		NEXT_GID = グラフィックID + 1
		;グラフィックの取り込み
		GCREATE グラフィックID, 横幅, 縦幅
		IF RESULT == 0
			DEBUGPRINTFORML グラフィックの作成に失敗しました。
			RETURN 0
		ENDIF
		GDRAWSPRITE グラフィックID, スプライト名B, 0, 0, 横幅, 縦幅
		GPLグラフィックID:GPL保有GID数 = グラフィックID
		GPLリソース名:GPL保有GID数 '= "[[BUF]]" + スプライト名B + "_" + TOSTR(縦幅) + "_" + TOSTR(横幅)
		GPL保有GID数++
		;DEBUGPRINTFORML グラフィック番号「{グラフィックID}」に「%スプライト名B%_{横幅}_{縦幅}」を登録しました。
		SPRITECREATE @"%スプライト名B%_{横幅}_{縦幅}", グラフィックID
	ENDIF
	表示スプライト名B '= スプライト名B + "_" + TOSTR(縦幅) + "_" + TOSTR(横幅)
ELSE
	;縦幅横幅の設定が無いならそのまま描画する
	表示スプライト名B '= スプライト名B
ENDIF

;グラフィックをクライアント領域に描画する
CBGSETBUTTONSPRITE ボタン番号, 表示スプライト名, 表示スプライト名B, x座標, y座標, z座標
RETURN 1

;********************************************************************************************
;スプライト背景ボタン押下チェック関数
;これを呼ぶとCBGボタン表示Sで作成したボタンを押下した値を返す
;GETKEY(0x01)を使用してマウスの左クリックを感知しているため、使用箇所に注意すること
;********************************************************************************************
@CBGボタン判定(判定消去フラグ = 0)
#FUNCTION
#DIM 判定消去フラグ			;このフラグが立っている場合、ボタンマップIDとの紐づけを消去してもう一度探す
#DIM ボタンマップID = -1	;一度判定を行うと、判定を行ったボタンマップのIDを保存する
#DIM 判定数値
判定数値 = -1
SIF 判定消去フラグ
	ボタンマップID = -1
IF ボタンマップID == -1
	;ボタンマップ用グラフィックを探し、そのグラフィックIDを使用する
	FOR LOCAL, 0, GPL保有GID数
		SIF GPLリソース名:LOCAL == ""
			BREAK
		IF GPLリソース名:LOCAL == "[[ボタンマップ]]"
			ボタンマップID = GPLグラフィックID:LOCAL
			LOCAL-- ;BREAK時に何故か再び加算されてしまうのでデクリメント
			BREAK
		ENDIF
	NEXT
	;ボタンマップのグラフィックIDがまだ作成されていない場合は終了する
	SIF LOCAL == GPL保有GID数
		RETURNF 0
ENDIF
;左クリックされた時にボタンマップの、現在マウスポインタがある部分の色を取る
IF GETKEY(0x01)
	判定数値 =  GGETCOLOR(ボタンマップID, MOUSEX(), LIMIT(CLIENTHEIGHT() + MOUSEY(), 0, CLIENTHEIGHT())) - 0xFF000000
	;DEBUGPRINTFORML 色取得：{GGETCOLOR(ボタンマップID, MOUSEX(), LIMIT(CLIENTHEIGHT() + MOUSEY(), 0, CLIENTHEIGHT())) - 0xFF000000}
ENDIF
RETURNF 判定数値

;********************************************************************************************
;背景画像表示終了関数
;これを呼ぶと背景表示した画像を全て、もしくは指定した2つのZ座標の範囲全ての画像表示を終了する
;これが呼ばれないとグラフィック破棄まで背景画像は常に表示されっぱなしになる
;********************************************************************************************
@CBG表示終了(z座標1 = 9999, z座標2 = 9999)
#DIM z座標1					;描画する際のz座標 0がテキスト描画領域 負数は手前を表す
#DIM z座標2					;同上
IF z座標1 == 9999 && z座標2 == 9999
	CBGCLEAR
ELSE
	CBGREMOVERANGE z座標1, z座標2
ENDIF
